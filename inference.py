import os
from dotenv import load_dotenv
from cerebras.cloud.sdk import Cerebras
from datetime import datetime, timedelta

# Load environment variables from cerebras_config.env file
load_dotenv("cerebras_config.env")


# TODO: figure out where each aircraft involved in bottleneck is supposed to depart to -- determines money at stake and # of people onboard
class CerebrasClient:
    def __init__(self):
        self.client = Cerebras(api_key=os.getenv("CEREBRAS_API_KEY"))

    def _read_transcribed_chatter(self, minutes_back: int = 15) -> str:
        """Read recent ATC chatter from transcribed_chatter.txt file"""
        chatter_file = os.path.join(
            os.path.dirname(__file__), "transcribed_chatter.txt"
        )

        if not os.path.exists(chatter_file):
            return "No ATC chatter file found."

        try:
            cutoff_time = datetime.now() - timedelta(minutes=minutes_back)
            recent_entries = []

            with open(chatter_file, "r") as f:
                lines = f.readlines()

            current_entry = []
            for line in lines:
                line = line.strip()

                # Skip header comments
                if line.startswith("#") or not line:
                    continue

                # Check for timestamp line
                if line.startswith("[") and "]" in line:
                    # Process previous entry if exists
                    if current_entry:
                        recent_entries.append("\n".join(current_entry))
                        current_entry = []

                    # Extract timestamp
                    timestamp_str = line.split("]")[0][1:]  # Remove [ and ]
                    try:
                        entry_time = datetime.strptime(
                            timestamp_str, "%Y-%m-%d %H:%M:%S"
                        )
                        if entry_time >= cutoff_time:
                            current_entry = [line]
                    except ValueError:
                        continue
                elif current_entry:  # Part of current entry
                    current_entry.append(line)

            # Don't forget the last entry
            if current_entry:
                recent_entries.append("\n".join(current_entry))

            if recent_entries:
                chatter_summary = f"""
LIVE ATC CHATTER CONTEXT ({minutes_back} minutes from transcribed_chatter.txt):
Current file contains {len(recent_entries)} recent ATC communications.

RECENT ATC COMMUNICATIONS:"""

                for i, entry in enumerate(recent_entries[-10:], 1):  # Last 10 entries
                    chatter_summary += f"\n{i}. {entry}"

                chatter_summary += "\n\nCRITICAL: Consider these live ATC communications when designing your action plan. Do NOT contradict recent controller instructions."

                return chatter_summary
            else:
                return "No recent ATC communications found in transcribed_chatter.txt"

        except Exception as e:
            return f"Error reading ATC chatter file: {str(e)}"

    def advise(self, bottleneck_data, squack_data):
        # Read ATC chatter context from file
        chatter_section = self._read_transcribed_chatter()

        prompt = f"""
        You are an expert in aviation and airport traffic control at John F Kennedy International Airport. An advanced machine learning model
        is constantly analyzing incoming aircraft data in JFK to predict where potential bottlenecks may occur. The following bottleneck data report 
        has been generated by the model: {bottleneck_data}.{chatter_section}
        
        Pay particular attention to the following fields in the bottleneck data report:
        - severity. Severity is a number between 1 and 5, where 1 is the lowest severity and 5 is the highest severity. It is the most important factor to consider when designing an action plan.
        - duration. Duration is the estimated duration of the bottleneck in minutes.
        - aircraft_count. Aircraft count is the number of aircraft that are predicted to be at risk from this bottleneck.
        
        As a senior Air Traffic Controller with decades of experience, analyze the aircraft that are predicted to be at risk from this bottleneck and design an action plan.
        Your action plan should involve aircraft-specific instructions that should be carried out in order to minimize delays and save costs for the airport.
        
        IMPORTANT: Your recommendations must be COMPATIBLE with the recent ATC chatter context above. If an aircraft has recently received specific taxi instructions or clearances, factor this into your plan. Do not recommend actions that would contradict recent controller instructions.
        
        Return your response in a JSON format where each key represents an incremental step with a targeted action that should be carried out. 
        Each step should include reasoning for why the action is necessary and what the expected outcome will be. The outcome for each step should be quantifiable in terms of the number of people benefitted, as well as the amount of money saved.
        These outcome metrics should be calculated based on the type of aircraft, as well as the airline that the aircraft is affiliated with.
        
        The final two keys of this JSON should include:
        - total_passengers_benefitted: the total number of passengers that will be benefitted by the action plan
        - total_cost_savings: the total amount of money that will be saved by the action plan
        """
        try:
            chat_completion = self.client.chat.completions.create(
                messages=[
                    {
                        "role": "user",
                        "content": prompt,
                    }
                ],
                model="gpt-oss-120b",  # qwen-3-32b
                max_tokens=2000,
                temperature=0.2,
            )

            if chat_completion.choices and len(chat_completion.choices) > 0:
                choice = chat_completion.choices[0]
                content = choice.message.content
                finish_reason = choice.finish_reason

                if content is None:
                    if finish_reason == "length":
                        return "Response was truncated due to max_tokens limit. Consider increasing max_tokens."
                    else:
                        return f"Content is None. Finish reason: {finish_reason}"

                return content
            else:
                return "No choices in response"

        except Exception as e:
            print(f"Error making API call: {e}")
            return None

    def test(self):
        bottleneck_data = {
            "bottleneck_id": "taxiway_2025-09-19_12:30:00",
            "coordinates": [40.638498, -73.774974],
            "timestamp": "2025-09-19 12:30:00",
            "type": "taxiway",
            "severity": 5,
            "duration": 26.0,
            "confidence": 1.00,
            "aircraft_count": 13,
            "aircraft_affected": [
                {
                    "flight_id": "EDV5399",
                    "aircraft_type": "B737",
                    "position": [40.635436, -73.781156],
                    "time": "2025-09-19T12:36:30",
                },
                {
                    "flight_id": "RPA5598",
                    "aircraft_type": "B737",
                    "position": [40.633073, -73.776862],
                    "time": "2025-09-19T12:35:14",
                },
                {
                    "flight_id": "JBU479",
                    "aircraft_type": "B737",
                    "position": [40.639664, -73.773443],
                    "time": "2025-09-19T12:31:48",
                },
                {
                    "flight_id": "JBU83",
                    "aircraft_type": "B737",
                    "position": [40.639966, -73.784330],
                    "time": "2025-09-19T12:30:21",
                },
                {
                    "flight_id": "ASA113",
                    "aircraft_type": "B737",
                    "position": [40.642234, -73.764978],
                    "time": "2025-09-19T12:33:12.883333",
                },
                {
                    "flight_id": "DAL1166",
                    "aircraft_type": "B737",
                    "position": [40.637127, -73.785238],
                    "time": "2025-09-19T12:36:32",
                },
                {
                    "flight_id": "DAL1368",
                    "aircraft_type": "B737",
                    "position": [40.635306, -73.775628],
                    "time": "2025-09-19T12:31:53.142857",
                },
                {
                    "flight_id": "RPA4338",
                    "aircraft_type": "B737",
                    "position": [40.641530, -73.772136],
                    "time": "2025-09-19T12:36:50",
                },
                {
                    "flight_id": "EDV4802",
                    "aircraft_type": "B737",
                    "position": [40.637450, -73.767204],
                    "time": "2025-09-19T12:35:57.050000",
                },
                {
                    "flight_id": "RPA4592",
                    "aircraft_type": "B737",
                    "position": [40.635489, -73.768618],
                    "time": "2025-09-19T12:32:08.333333",
                },
                {
                    "flight_id": "AAL374",
                    "aircraft_type": "B737",
                    "position": [40.641520, -73.767493],
                    "time": "2025-09-19T12:34:41",
                },
                {
                    "flight_id": "EDV5370",
                    "aircraft_type": "B737",
                    "position": [40.641325, -73.785946],
                    "time": "2025-09-19T12:37:01",
                },
                {
                    "flight_id": "JBU717",
                    "aircraft_type": "B737",
                    "position": [40.640350, -73.771626],
                    "time": "2025-09-19T12:34:03",
                },
            ],
        }
        # Test with mock chatter context
        test_chatter_context = {
            "time_window_minutes": 10,
            "total_communications": 3,
            "active_aircraft": ["DAL1166", "JBU479", "AAL374"],
            "active_runways": ["22L", "13R"],
            "active_taxiways": ["A", "B"],
            "recent_chatter": [
                {
                    "timestamp": "2025-09-19T12:30:00",
                    "transcription": "Delta 1166 taxi via alpha to runway 22L",
                    "aircraft": ["DAL1166"],
                    "command_type": "taxi",
                    "confidence": "high",
                },
                {
                    "timestamp": "2025-09-19T12:31:00",
                    "transcription": "JetBlue 479 hold short runway 13R",
                    "aircraft": ["JBU479"],
                    "command_type": "hold",
                    "confidence": "high",
                },
            ],
            "command_summary": {
                "taxi": 1,
                "hold": 1,
                "clearance": 0,
                "contact": 1,
                "other": 0,
            },
            "high_confidence_count": 2,
        }

        return self.advise(bottleneck_data, "")


client = CerebrasClient()
print(client.test())
